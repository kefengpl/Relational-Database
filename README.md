# bustub 小型关系型数据库内核

## Proj2
**难点1**
- B+ 树本身逻辑复杂，既要考虑叶子结点，又考虑树结点，结点的分裂、合并、根的转换等十分复杂。但是，不必严格按照教材算法实现，多看几个动态插入、删除的图解，然后凭感觉和逻辑就可以把B+树的增删改查写出来。

**难点2**
- 实现线程安全的、支持并发的B+树。此时，你需要用到 PageGuard 自动释放读锁，自动取消钉住页面。加锁算法：① 对于查找操作，子结点上锁之后，可立即释放双亲结点的锁；② 插入操作，子结点上锁且未满，(从而分裂不会影响到它的祖先)，释放所有祖先结点。③ 删除操作：对于某个内部结点 > 半满才可(注意是大于，不能等于)认为其祖先结点是安全的；对于某个叶子结点，也是 > 半满，则其祖先安全；此外，无论叶子、非叶子，对于根结点的要求低一些，满足至少有一个key(对内部结点而言，这意味着有两个孩子指针)即可。
- 虽然乐观锁也可以实现且性能更好，但其实现显然在本人能力范围之外。

**难点3**
- 控制Evict策略，及时取消钉住页面，防止缓存池爆满带来的下面的各种BUG。
- 这通过 PageGurad 和加锁统一管理即可。自动释放资源比手动释放友好很多，这就是 C++ RAII ，即通过一个对象的生命周期管理堆内存的资源。

**Bug1 数组越界带来的未知行为：[此处是数组越界导致其后的字段page_id_部分覆盖，从而 page 无法释放]**
- 由于数组越界导致 page_id 发生了改变。而数组越界是由于叶子的深度没有上限控制，为什么叶子的上限会超过3？
- 因为在原来的实现中，叶子结点分裂分两步，先插入新结点，使得叶子结点溢出；然后再一分为二。如果叶子结点插入溢出之后，发现缓冲池是满的，无法
分裂，函数就直接返回了，叶子结点会持续处于溢出状态，并且溢出之后 IsFull 会返回 false(IsFull 采用等号判断)，使得阶为3的叶子结点也能插入245个(key, value)键值对。如果 buffer_pool 较小，叶子结点最终会溢出而无法分裂，溢出会导致数组越界，Page 的 page_id_ 会被部分覆盖写入，从而导致Pageguard在释放这个页时无法匹配原来的 page_id_[可扩展哈希表查找失败]，释放失败，这个页就会长期驻留在缓冲池中。

- 为什么buffer_pool较小而数据规模scale较大时，会直接卡死？比如 size = 30 的 buffer_pool，B+ 树的 n(阶)保持最大(245)，插入 1000 个数据会在 9452 左右卡死？
- 直接卡死是因为缓冲池满了，没有可驱逐的页面，无法从磁盘中读入新的页面了，程序无法向下运行。
- size = 30 的缓冲池是够用的，并不是不够，因为B+树，特别是240+阶的B+树，深度不会超过5，递归调用不会过多。之所以缓冲池会逐步变满导致卡死，是因为：245深度的叶子结点，如果采用“先插入(从而导致页溢出，会占用其它未知内存)，再分裂”的方式，会导致这个短时间溢出的叶子结点的page_id_发生变化(内存溢出，覆盖写入page_id_)，从而Pageguard在释放这个页时无法匹配原来的 page_id_，pin_count_ 无法减到0，这个页会长期驻留在缓冲池中。这会导致缓冲池的空间越来越小，最终填满整个缓冲池。

- 缓冲池相对于插入的结点数量而言过小会导致哪些问题？
- 因为buffer_pool较小，会导插入结点后分裂失败(前提是采用先插入[会有一段时间溢出]，后分裂)(不能获取到新的page)，导致数组越界(本来希望最多存俩key，结果存了253个key)[注意：这种情况由查找算法也不会找到插入的那些数据]，数组越界就会修改其后面 page_id_ 的数值。page_id_ 改变会导致页面释放失败，从而 buffer_pool 很快会被占满，内存无法及时得到释放，(以 key == 3 为例)即本次 Insert 之后，叶子结点大小变成 3，之后变成 4 ...(IsFull仅对等于keynum==2的情况生效)

- 解决方案：① 从根本上，应该防止数组越界，防止任何页出现短暂的“溢出”，从而防止页面无法被及时释放。② 及时 EVICT 不需要的页面，当然这使用 PageGuard 进行保护即可。② 用户输入的 size，你在构造函数里×2，“预留空间”，比如 pool_size = 2 * size，将缓冲池内部设置的比较大即可，但这只是权宜之计，不是什么好办法，因为程序本身就有问题。

**Bug2 PageGuard本身存在的Bug**
- 等号构造时要先舍弃自己的资源，然后才能接收别人的资源。
```C++
auto operator=(ReadPageGuard &&that) noexcept -> ReadPageGuard & {
    if (this == &that) {
      return *this;
    }
    //! \bug 注意：一定要先放弃当前拥有的资源！
    Drop();                         
    guard_ = std::move(that.guard_);  // 等号赋值转移所有权，这可以保证锁的状态是不变的。
    return *this;
  }
```
- 防止一个锁或者一个资源被释放两次。

**Bug3 B+树实现本身的BUG**
- 比如左右兄弟写错、交换或借入的结点不对等各类问题。但幸好该实验提供了B+树可视化工具，方便调试。


